<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>算法</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
}

.simple-table-header {
	background: rgb(247, 246, 243);
	color: black;
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(145, 145, 142, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(187, 132, 108, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(215, 129, 58, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 148, 51, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(108, 155, 125, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(91, 151, 189, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(167, 130, 195, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(205, 116, 159, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(225, 111, 100, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="d6413498-4a24-4423-b1b8-762b90a9b511" class="page mono"><header><h1 class="page-title">算法</h1></header><div class="page-body"><h1 id="1f4c3638-a325-477a-a6be-0d784a36a9c3" class=""><details open=""><summary>排序算法</summary></details></h1><div class="indented"><p id="940b04ce-2e6c-49d9-bc93-220ed384ec30" class="">—冒泡排序：找到最大的放到最后</p><pre id="0fa2601d-022e-4eff-8a2e-f9398a2c896f" class="code"><code>public static void bubbleSort(int[] arr) {
		if (arr == null || arr.length &lt; 2) {
			return;
		}
		// 0 ~ N-1
		// 0 ~ N-2
		// 0 ~ N-3
		for (int e = arr.length - 1; e &gt; 0; e--) { // 0 ~ e
			for (int i = 0; i &lt; e; i++) {
				if (arr[i] &gt; arr[i + 1]) {
					swap(arr, i, i + 1);
				}
			}
		}
	}

	// 交换arr的i和j位置上的值
public static void swap(int[] arr, int i, int j) {
	arr[i] = arr[i] ^ arr[j];
	arr[j] = arr[i] ^ arr[j];
	arr[i] = arr[i] ^ arr[j];
}</code></pre><p id="8c16683b-5077-4d6d-a920-1b556fb4a4f5" class="">—插入排序：从0到N，让0到N这个范围里面是有序的找到这里大的去交换</p><pre id="a4ec3373-d1cc-4a4d-af72-22af4e2368e5" class="code"><code>public static void insertionSort(int[] arr) {
		if (arr == null || arr.length &lt; 2) {
			return;
		}
		// 不只1个数
		for (int i = 1; i &lt; arr.length; i++) { // 0 ~ i 做到有序
			for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {
				swap(arr, j, j + 1);
			}
		}
	}

	// i和j是一个位置的话，会出错
	public static void swap(int[] arr, int i, int j) {
		arr[i] = arr[i] ^ arr[j];
		arr[j] = arr[i] ^ arr[j];
		arr[i] = arr[i] ^ arr[j];
	}</code></pre><p id="1a02d450-ecf3-4d1e-97a3-b5148293ff55" class="">—选择排序，从0-N到N找到最小值的下标进行交换的一个dadongzuo</p><pre id="39f38b82-5ae1-4c92-bdc0-3ef3e400cff1" class="code"><code>public static void selectionSort(int[] arr) {
		if (arr == null || arr.length &lt; 2) {
			return;
		}
		// 0 ~ N-1  找到最小值，在哪，放到0位置上
		// 1 ~ n-1  找到最小值，在哪，放到1 位置上
		// 2 ~ n-1  找到最小值，在哪，放到2 位置上
		for (int i = 0; i &lt; arr.length - 1; i++) {
			int minIndex = i;
			for (int j = i + 1; j &lt; arr.length; j++) { // i ~ N-1 上找最小值的下标 
				minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;
			}
			swap(arr, i, minIndex);
		}
	}

	public static void swap(int[] arr, int i, int j) {
		int tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}</code></pre></div><h1 id="52681d7f-d9e9-4ec3-9e33-d56d97a4c022" class=""><details open=""><summary>前缀和方法</summary></details></h1><div class="indented"><p id="cd7935e1-e991-4ee1-a835-2052f3f2f2a4" class="">主要适用场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。</p><pre id="6fe5580b-0661-443a-9853-afa13e744a3a" class="code"><code>class PrefixSum {
	private int[] prefix;

	public PrefixSum(int[] nums) {
		prefix = new int[nums.length +1];
		for (int i = 1; i &lt; prefix.length; i++) {
			prefix[i] = prefix[i-1] + nums[i-1];
		}
	}

	public int query(int i, int j) {
		return prefix[j+1] - prefix[i];
	}
}</code></pre><p id="42a54dc2-4b38-428d-bd7c-0bca6a805919" class="">leetcode303 一维数组</p><pre id="51c1b8eb-6f61-4535-9d67-7e3f6366d4da" class="code"><code>class NumArray{
//前缀和数组
	private int[] preSum;
	//输入一个数组，构造前缀和
	public numArray(int[] nums) {
		//preSum[0] = 0这样方便计算累加
		presum = new int[nums.length+1];
		for (int i = 1; i &lt; preSum.length; i++){
			preSum[i] = preSum[i-1] + nums[i-1];
		}

	}
	/*闭区间看[left, right]的累加和*/
	public int sumRange(int left, int right) {
		return preSum[right+1] - preSum[left];
	}
}</code></pre><p id="28baf866-6a8a-40c5-beda-9bee9f8cd116" class="">
</p><p id="e2c6b1fe-ac3b-4a97-8b61-9d4bf495e8e4" class="">leetcode304 二维数组</p><pre id="94f71203-99b0-492f-be3a-cbca0d2c50a4" class="code"><code>class NumMatrix {
    //preSum[i][j]记录[0, 0, i, j]的元素和
    private int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        if (m == 0 || n == 0) {
            return;
        }
        preSum = new int[m+1][n+1];
        for (int i = 1; i &lt;=m; i++) {
            for (int j = 1; j &lt;=n; j++) {
                //计算每个矩阵[0, 0, i, j]的元素和
                preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1];
            }
        }
    }

    public int sumRegion(int x1, int y1, int x2, int y2) {
        return preSum[x2+1][y2+1] - preSum[x1][y2+1] 
        - preSum[x2+1][y1] +  preSum[x1][y1];
    }
}</code></pre></div><h1 id="d89f1f43-d258-4e1f-89e2-fd60f363ba0c" class=""><details open=""><summary>二分搜索</summary></details></h1><div class="indented"><h2 id="73fe2dd4-a908-4752-bab7-5f1134609757" class=""><details open=""><summary><strong>搜索一个元素</strong></summary></details></h2><div class="indented"><p id="8e40d6c5-f058-4bf6-973d-e7031ff8791d" class="">搜索一个元素时，搜索区间两端闭。while条件带等号，否则需要打补丁。if想等就反悔，其他的事甭操心。mid必须加减1， 因为区间两端闭。while结束就凉凉，凄凄惨惨返-1.</p><p id="49921eba-bce4-4b9c-91f3-543c6faacaea" class="">leetcode704</p><pre id="5d5877ef-bbd2-40ad-8f1f-30bfc845c12b" class="code"><code>public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left &lt;= right) {
            int mid = left + (right - left) /2;
            if (nums[mid] == target) return mid;
            else if (nums[mid] &lt; target) left = mid + 1;
            else if (nums[mid] &gt; target) right = mid -1;
        }
        return -1;
        

    }
}</code></pre><p id="206428a9-f54e-4c4b-804c-f004dbbd685b" class="">几个问题：</p><p id="658b6b42-c68f-486c-bd8f-28acfd1e7452" class="">1.为什么while循环的条件中时≤不是&lt;？</p><p id="71acabcc-9d1f-413f-8256-cac0e3c22918" class="">因为初始化right的值时nums.length-1，最后一个元素的索引不是nums.length</p><p id="59d1ad16-2cd4-4d94-95d2-4cbcad65fa4c" class="">这两者可能出现在不同功能的二分查找中，区别是什么：前者相当于两端都在闭区间[left, right]，后者相当于左闭右开区间[left, right)，因为索引大小nums.length是越界的</p><p id="1776b77c-f40c-4e8b-bde0-83eca3271286" class="">我们这个算法中使用的前者[left, right]两端都闭的区间，这个区间就是每次进行搜索的区间，那么什么时候应该停止搜索呢，就是找到目标值</p><pre id="58adc5a3-7ad2-45c3-8d0d-f3cbc7640beb" class="code"><code>if(nums[mid] == target){
	return mid
}</code></pre><p id="3f48752c-0442-40d9-ac90-a7fb0ebad076" class="">但是如果没有找到，就需要while玄幻终止，返回-1。那while循环什么时候应该终止呢？搜索区间为空的时候应该终止，意味着我没得找了，也就是说什么都没有找到。</p><p id="214909c0-faf7-4698-af13-0ca8255c10a3" class="">
</p><p id="390329be-7b92-4b27-a2c7-fde47aa400ad" class="">具体来说，while(left≤right）的终止条件时left = right+1，携程区间的形式就是[right+1,. right]这个时候区间唯恐，因为没有数字同时大于3小于2对吧，所以这个时候while循环终止是正确的，直接返回-1即可</p><p id="3bef9290-fb2d-42d7-81ff-f829a25c1af7" class="">
</p><p id="ffabdb6c-d67d-41c3-8ecc-5077ed611bdf" class="">while(left &lt; right)的终止条件是left==right，携程区间的形式就是[right, right]，带个数字进去[2, 2]，这个时候区间非空，还有一个数字2，但此时while循环终止了，也就是说这区间2被漏掉了还没有搜索了却返回了-1，当然如果最后判断一波left right也不是问题，但是好麻烦了，王同学最烦磨磨唧唧了</p><pre id="73578768-7c7f-4794-856b-5e1cabcd0aa4" class="code"><code>while (left &lt; right) {
	//......
}
return nums[left] == target? left : -1;</code></pre><p id="e4613e4b-062c-453f-8814-ecb250a94cdb" class="">
</p><p id="1bda728d-a295-486b-8a9e-d749943405a0" class="">2.为痕么left = mid+1， right = mid -1？有的代码是right = mid， 或者left = mid，到底有没有一个定式什么时候加什么时候减？？</p><p id="6f210ac8-8207-4003-b8fb-d14384782e95" class="">
</p><p id="18e94186-4489-4327-b56c-bdf2d00f40d9" class="">这的确是一个不好理解的点，困扰小王本人很句，但是理解之前写的内容，很容易判断，我们明确了搜索区间这个盖脸，而且搜索区间都是闭的，[left, right]当我们发现mid不是我们想要的target下一步是搜索哪里呢</p><p id="b7a82e4a-1aeb-41a8-a075-8fad34b8fd99" class="">一定是搜索[left, mid-1] or [mid+1, right]因为我们已经搜索过mid，所以mid应该从搜索区间里剔除。</p><p id="acfc0ceb-e3e9-4d5d-ade1-54587b0ebeb7" class="">
</p><p id="48c3e182-af44-4611-a4d5-65b5ba64b9de" class="">3.shortcomings</p><p id="1ea3c1af-2e52-4edf-8d56-9fd58693349c" class="">这个算法存在部分局限性。比如说有序数组 nums = [2, 2, 2, 2, 3] 当target为2的时候，索引是2， 但是左侧边界右侧边界你没法找到，用这个方法很鸡肋，那么怎么办呢</p><p id="cefdd827-a53e-4496-8943-2729c2ce5187" class="">
</p><p id="0068a41a-10a8-4013-a59f-c58af72232f7" class="">我们接下来介绍另外两种二分查找的算法</p></div><h2 id="443a0151-28ea-4afa-8bd2-6fefd49be5f0" class=""><details open=""><summary><strong>搜索左侧边界</strong></summary></details></h2><div class="indented"><p id="d5b2d82e-50f8-4f75-8afd-cdc50c1c5483" class="">
</p><pre id="d564d874-1f0c-4ea1-ad42-040eed86bae4" class="code"><code>int left_bound(int[] nums, int target) {
	if (nums.length == 0) return -1;
	int left = 0;
	int right = nums.length; //notice
	
	while (left &lt; right) {
		int mid = left + (right - left)/2;
		if (nums[mid] == target) {
			right = mid;
		}
		else if (nums[mid] &lt; target) {
			left = mid+1;
		}
		else if (nums[mid] &gt; target) {
			right = mid;
		}
	}
}</code></pre><p id="1b8855d0-9e22-4f35-875f-31dee0ea2225" class="">
</p><p id="9af9f6b0-3fc8-4c2a-85c5-7d130899b873" class="">1.为什么while中是&lt; 而不是 ≤</p><p id="bf53dcc4-fddd-46da-99f8-ed25e3dfcae4" class="">用相同的方法分析，因为right = nums.length而不是nums.length -1因此每次循环的搜索区间是[left, right)左闭右开</p><p id="55097f2e-4596-4f65-830f-efe65e1f6032" class="">while(left &lt; right)的终止条件是left == right 刺死左闭右开的话就是空，所以可以正确终止</p><p id="8eb62f05-5e5f-4847-921f-98012f4162ba" class="">有的人就会问了为什么这里面right不是nums.length-1？你要是想这么写我后面也有写法，我就是觉得麻烦。</p><ol type="1" id="18153beb-d8eb-40e6-b7dc-cef1414f36d8" class="numbered-list" start="2"><li>为什么没有返回-1的操作</li></ol><p id="26b71a8c-62e4-4d05-90c2-105fb7b53ff5" class="">因为这里找到边界其实可以理解为有多少数字比你要找的这数字小</p><p id="1b1a741e-dbdd-4cd8-8d5b-ae493c05c1c8" class="">For example，</p><p id="6493e867-264f-40a7-a138-a3f22f05327d" class="">nums = [2, 3, 5, 7] and target = 1.</p><p id="8d5ef093-1da8-4d02-bfc1-c58f37c36c20" class="">return 0 ===》nums中小于1的元素有0个</p><p id="b1ce4055-6ba3-49c8-93af-ef8d2d9366cc" class="">
</p><pre id="0f757a03-78e1-4a5a-ba1b-8febfc1504b5" class="code"><code>while (left &lt; right) {
	//...
}
if (left == nums.length) return -1;
return nums[left] == target ? left : -1;</code></pre><p id="c10de528-4df2-4aaf-9a4c-411911782f85" class="">
</p><p id="57c8d1f9-0106-471c-93ee-779ffc8f3e70" class="">3.为什么 left = mid + 1， right = mid</p><p id="08427e69-2dac-4a30-8bb3-a6944425c57c" class="">很好解释，因为搜索区间时左闭右开，当mid被检测后，分隔开的两个区间是[left, mid) [mid+1, right)</p><p id="a1d4316f-185d-4527-8d5f-dff48f6a88cd" class="">
</p><ol type="1" id="6fb14425-6062-448d-9d53-2bda4f514655" class="numbered-list" start="4"><li>为什么这个算法能够搜索左侧边界 </li></ol><p id="90493646-6980-40a2-ba00-0853e7cfb6ce" class="">对于nums[mid] == target这种情况的处理</p><pre id="201c1bea-c7d6-4bfd-a3d3-381bec038dd3" class="code"><code>if (num[mid] == target) {
	right = mid;
}</code></pre><p id="bff46af1-8c1b-4c48-b8e0-cc9323f0b12f" class="">可见在找到target的时候没有立即返回，而是逐渐缩小搜索上界，不断向左搜索</p><p id="98e3e43a-bb0d-4574-a20f-a593be26509d" class="">
</p><p id="c19a8999-0f9b-4164-9ee9-825e1e3474cd" class="">5.为什么返回left不是right</p><p id="fa3bc151-a260-4c9c-83b7-5d16ca6e520a" class="">我愿意，你看最后终止条件是left == right</p><p id="5929225d-03c7-4f94-b555-61bdefff8e98" class="">
</p><p id="95e03f41-9595-43f0-a99f-7255596fe1a2" class="">6. 能不能把right改成nums.length-1,也就是继续两边闭区间，这样就可以统一一下</p><pre id="5533c103-05a0-49bf-af69-00893c7668e6" class="code"><code>int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    // 检查出界情况
    if (left &gt;= nums.length || nums[left] != target) {
        return -1;
    }
    return left;
}</code></pre></div><h2 id="e4ae1c66-71f3-436e-a9e5-03048ac103c8" class=""><details open=""><summary>搜索<strong>右侧边界</strong></summary></details></h2><div class="indented"><pre id="a52e02e0-d387-463c-b4ee-8443f257b92a" class="code"><code>int right_bound(int[] nums, int target) {
	if(nums.length == 1) return -1;
	int left = 0, right = nums.length;
	while (left &lt; right){
		int mid = left + (right - left)/2;
		if (nums[mid] == target) {
			left = mid+1;
		} else if (nums[mid] &lt; target) {
			left = mid+1;
		} else if (nums[mid] &gt; target) {
			right = mid;		
		}
	}
	return left-1;
}</code></pre><ol type="1" id="c6190732-0ffe-40f1-b340-4b3ee1f55cca" class="numbered-list" start="1"><li>为啊什么这个算法能够找到右侧边界？</li></ol><p id="987d9e0b-240d-4441-bae3-48b51812bb32" class="">很简单，关键点就是在</p><pre id="a328f708-acaf-46c4-b0e7-6e427e8c5f59" class="code"><code>if (nums[mid] == target) {
	left = mid+1;
}</code></pre><p id="9dbe80eb-8047-431b-aeaf-d514bc24c00a" class="">当等于target的时候，不要立即返回，而是增大搜索区间的下界，使得区间不断向右收缩，达到锁定边界的目的</p><p id="1ce40956-df15-4cdf-bf7a-c732b9d0160b" class="">2.为什么最后返回的是left-1</p><p id="dcae53bb-3a8c-430d-a40c-4fe4ee798d64" class="">因为我们对于left的更新必须是mid+1，也就是说while循环结束的时候nums[left]一定不会等于target，但是left-1可能是target</p><p id="bc1ebec8-6513-40bb-a68e-bd5fb3b9db95" class="">3.为什么没有返回-1的操纵，如果nums中不存在target这个值怎么办呢</p><p id="828698fe-1a70-4baa-9709-902d24456f18" class="">类似之前的左侧边界搜索，因为while的终止条件是left == right，就是说left的取值范围是[0, nums.length]</p><pre id="8a276330-e547-4a8d-9cb9-40212be836a7" class="code"><code>while (left &lt; righ) {
	//...
}
if (left == 0) return -1;
return nums[left-1] == target ? (left-1):-1;</code></pre><p id="f3ee5687-8b24-4e64-afc0-a37ee32de70e" class="">4.那么是否可以统一成两端都闭的形式呢？？？</p><pre id="0e90c9ae-93bc-49a3-aef8-0921f03146f1" class="code"><code>int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] &lt; target) {
            left = mid + 1;
        } else if (nums[mid] &gt; target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 这里改为检查 right 越界的情况，见下图
    if (right &lt; 0 || nums[right] != target) {
        return -1;
    }
    return right;
}</code></pre><p id="ad81cbd3-f94c-45b6-9d29-90207f6cf446" class=""><div class="indented"><p id="cf6763df-a903-414d-90e3-bebde96bf9a0" class="">
</p></div></p></div><h2 id="9bf64493-d117-4603-ac20-02f2f8f0e2c0" class=""><details open=""><summary>例题</summary></details></h2><div class="indented"><h3 id="eb187396-ce39-407b-9797-8c6a171a37a8" class=""><details open=""><summary>Leetcode875</summary></details></h3><div class="indented"><pre id="f5754d57-1b03-4390-91da-90292624a4de" class="code"><code>class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1;
        int right = 1000000000 + 1;
        while (left &lt; right) {
            int mid = left + (right -left) / 2;
            if (f(piles, mid) &lt;= h) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;

    }
    int f(int[] piles, int x) {
        int hours = 0;
        for (int i =0; i &lt; piles.length; i++) {
            hours += piles[i] / x;
            if (piles[i] % x &gt; 0 ){
                hours++;
            }
        }
        return hours;
    }
}</code></pre></div><h3 id="df329c96-3aa3-455f-9e10-82f3a57c1f18" class=""><details open=""><summary>Leetcode1011</summary></details></h3><div class="indented"><pre id="0906621e-fa61-4f5f-955e-f06e0627a950" class="code"><code>class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int left = 0;
        int right = 1;
        for (int w : weights) {
            left = Math.max(left, w);
            right += w;
        }

        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (f(weights, mid) &lt;= days){
                right = mid;
            } else {
                left = mid +1;
            }
        }
        return left;

    }

    int f(int[] weights, int x) {
        int days = 0;
        for (int i = 0; i &lt; weights.length;) {
            int cap = x;
            while (i &lt; weights.length) {
                if (cap &lt; weights[i]) break;
                else cap -= weights[i];
                i++;
            }
            days++;
        }
        return days;
    }
}</code></pre></div><h3 id="19c7989e-0324-439f-bde9-21957d2f58be" class=""><details open=""><summary>LeetcodeXXX</summary></details></h3><div class="indented"><p id="90437aae-81f8-4991-8e66-7c19f9036746" class="">查找排序数组中元素的第一个和最后一个位置</p><pre id="faed8ff6-0a8f-4042-a2b1-a9ad3d3dd7e8" class="code"><code>class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] ans = new int[2];
        ans[0] = leftbinarySearch(nums, target);
        ans[1] = rightbinarySearch(nums, target);
        return ans;

    }
    public int leftbinarySearch(int[] nums, int target){
        int left = 0;
        int right = nums.length;
        while (left &lt; right) {
            int mid = left + (right - left) /2;
            if (nums[mid] &gt;= target) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        if (left == nums.length) return -1;
        return nums[left] == target ? left : -1;
    }

    public int rightbinarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        while (left &lt; right) {
            int mid = left + (right-left)/2;
            if (nums[mid] &gt; target) {
                right = mid;
            } else if (nums[mid] == target) {
                left = mid + 1;
            } else {
                left = mid + 1;
            }
        } 
        if (left == 0) return -1;
        return nums[left-1] == target ? (left-1):-1;
    }
}</code></pre></div><h3 id="72c9eeb6-cc5a-41f3-bfcc-06d59b17a6a6" class=""><details open=""><summary>LeetcodeXXX</summary></details></h3><div class="indented"><pre id="fb10e1f3-a633-4512-b051-2eee7eff31b3" class="code"><code>public class Solution {
 	public List&lt;Integer&gt; findClosestElements(int[] arr, int k, int x) {
        List&lt;Integer&gt; ret = Arrays.stream(arr).boxed().collect(Collectors.toList());
		int n = ret.size();
		if (x &lt;= ret.get(0)) {
			return ret.subList(0, k);
		} else if (ret.get(n - 1) &lt;= x) {
			return ret.subList(n - k, n);
		} else {
			int index = Collections.binarySearch(ret, x);
			if (index &lt; 0)
				index = -index - 1;
			int low = Math.max(0, index - k - 1), high = Math.min(ret.size() - 1, index + k - 1);

			while (high - low &gt; k - 1) {
				if ((x - ret.get(low)) &lt;= (ret.get(high) - x))
					high--;
				else if ((x - ret.get(low)) &gt; (ret.get(high) - x))
					low++;
				else
					System.out.println(&quot;unhandled case: &quot; + low + &quot; &quot; + high);
			}
			return ret.subList(low, high + 1);
		}
	}
}
</code></pre></div></div></div><h1 id="6f240046-1c9e-4eb6-9fe2-230e47158ceb" class=""><details open=""><summary>差分数组</summary></details></h1><div class="indented"><p id="90dc630e-cca2-43c6-9f85-731b10b20930" class=""><strong>差分数组的主要运用场景是频繁丢原始数组的某个区间的元素进行增减。</strong></p><p id="cd3a285f-91c0-414e-af6a-947647cae15d" class="">根据原数组得到差分数组</p><pre id="edf76097-10fc-4651-99a8-827961b3196d" class="code"><code>int[] diff = new int[nums.length];
diff[0] = nums[0];
for (int i = 1; i &lt; nums.length; i++) {
	diff[i] = nums[i] - nums[i-1];
}</code></pre><p id="6f857fe1-641b-4a4b-8015-7f3e8a6f2649" class="">根据差分数组得到原数组</p><pre id="5069feb5-91a8-4e74-8281-e123be2c6557" class="code"><code>int[] res = new int[diff.length];
res[0] = diff[0];
for (int i = 1; i &lt; diff.length; i++) {
	res[i] = res[i-1] + diff[i];
}</code></pre><p id="b100b3a6-102c-4232-9f90-48f835532d23" class="">
</p><p id="61f1f950-a57c-4aac-80a1-b5dda0cca15f" class="">整体代码</p><pre id="237161bc-696c-4644-94db-ff6c0915c49c" class="code"><code>class Difference {
	private int[] diff;

	public Difference(int[] nums) {
		assert nums.length &gt; 0;
		diff = new int[nums.length];
		diff[0] = nums[0];
		for (int i = 1; i &lt; nums.length; i++) {
			diff[i] = nums[i] - nums[i-1];
		}
	}

	public void increment(int i, int j, int val) {
		diff[i] += val;
		if (j + 1 &lt; diff.length) {
			diff[j+1] -= val;
		}
	}

	public int[] result() {
		int[] res = new int[diff.length];
		res[0] = diff[0];
		for (int i = 1; i &lt; diff.length; i++) {
			res[i] = res[i-1] + diff[i];
		}
		return res;
	} 
}</code></pre><h1 id="120a755b-15e7-476b-99cf-564f42479e39" class=""><details open=""><summary>滑窗问题</summary></details></h1><div class="indented"><p id="7f9814fe-59cf-4c61-ab2f-1c8faca2f240" class="">滑动窗口防滑口诀</p><p id="d53f6841-a36c-45cc-b6ff-a3404cd7c356" class="">链表子串数组题，用双指针别犹豫</p><p id="a1ad326c-ba57-429a-8f87-36edc1518ab7" class="">双指针家三兄弟，各个都是万人迷</p><p id="6818df2e-2069-42a4-a9a6-cd9557be6c44" class="">快慢指针最神奇，链表操作无压力</p><p id="08adb944-9e9f-4141-b4c6-3575bb821241" class="">归并排序找中点，链表成环搞判定</p><p id="a780a782-fed8-473e-9e36-16480b089b1a" class="">左右指针最常见，左右两端相向行</p><p id="f5d9ce3e-6115-4033-8bb7-1c5c9defb388" class="">反转数组要靠他，二分搜索是弟弟</p><p id="ea00d7da-eadf-4b7e-9927-a967f8a214f2" class="">滑动窗口老猛男，子串问题全靠他</p><p id="c537e7b0-03b0-4e14-934a-ba4012cb78a9" class="">左右指针滑窗口，一前一后齐头进</p><p id="d6c1b0fc-d52b-471b-bfe9-e330dd278028" class="">
</p><pre id="51e0bd1f-6e30-44ac-aa72-9375fdf6371f" class="code"><code>int left = 0, right = 0;
while (right &lt; s.size()) {
//增大窗口
	window.add(s[right]);
	right++;

	while (window needs shrink) {
//缩小窗口
		window.remove(s[left]);
		left++;
	}
}
//时间复杂度O(n)</code></pre></div><p id="5db2e811-b1da-4846-9f25-4d367cd97fe4" class="">
</p><pre id="803c9b22-c514-4ce4-b8bd-77242e62ece8" class="code"><code>
//一系列框架
void slidingWindow(string s, string t) {
	unordered_Map&lt;char, int&gt; need, window;
	for (char c: t) {need[c]++;}
	int left = 0, right = 0;
	int valid = 0;
	while (right &lt; s.size()) {
		//c是即将移入窗口的字符
		char c = s[right];
		//右移窗口
		right++;
		//窗口内数据一系列更新
		...
		//debug输出的位置
		printf(&quot;window: [%d, %d)\n&quot;, left, right);
		//判断左侧窗口是否要收缩
		while (window needs shrink) {
			//d是将移出窗口的字符
			char d = s[left];
			//左移窗口
			left++；
			//窗口一系列的更新
			...
		}
	}

}</code></pre></div></div></article></body></html>