# 小王同学滴刷题记录

### 声明：

该刷题记录仅供参考以及学习方法，请勿直接ctrl cv到自己的作业上面去，作者概不负责。。。。。。。。。

##  Codeforce

### 4A

#### Watermelon

**题目内容**： 把一个整数分成两个相同的正整数，并使这两个正整数都是二的倍数

**分析**： 既然分成两个正整数且都是二的倍数那么这个一定是 $num = 2(a+b)$       $(a, b > 0) $

**代码**：

C++

```c++
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int a;
    cin >> a;
    if (a == 2) {
        cout << "NO" << endl;
        return;
    }
    if (a % 2 == 0) {
        cout << "YES" << endl;
        return;
    } else {
        cout << "NO" << endl;
        return;
    }
}

int main() {
    solve();
}
```



Python3

```python
n = int(input())
def solve(n):
    if n == 2:
        print("NO")
        return
    if n % 2 == 0:
        print("YES")
        return
    print("NO")

solve(n)
```



Java

```java
import java.util.*;


class A_Watermelon{
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        solve(n);

    }

    static void solve(int n) {
        if (n == 2) {
            System.out.println("NO");
            return;
        }
        if (n % 2 == 0) {
            System.out.println("YES");
            return;
        } else {
            System.out.println("NO");
            return;
        }

    }
}
```

// 22.1.18

### 71A

#### Way too long words

**题目内容**：缩略单词，长度大于10就保留开头结尾中间数字是没写的单词的个数

**分析**：if判断长度，print出来

**代码**：

Python

```python
t = int(input())

def solve(word):
    n = len(word)
    if n > 10:
        begin = word[0]
        end = word[-1]
        res = begin + str(n-2) + end
        print(res)
        return
    else:
        print(word)
        return

for i in range(t):
    word = input()
    solve(word)
```



C++

```C++
#include<bits/stdc++.h>
using namespace std;

void solve(string word) {
    int n = word.length();
    if (n > 10) {
        char begin = word.at(0);
        char end = word.at(n-1);
        cout << begin << n-2 << end << endl;
    } else {
        cout << word << endl;
    }

}
int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        string word;
        cin >> word;
        solve(word);
    }

    return 0;
}
```



Java 

```java
import java.util.* ;


class A_Way_Too_Long_Words{
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for (int i = 0; i <= t; i++){
            String word1 = s.nextLine();
            solve(word1);
        }
        s.close();
    }

    static void solve(String word) {
        int n = word.length();
        if (n > 10) {
            char begin = word.charAt(0);
            char end = word.charAt(n-1);
            Integer a = n-2;
            System.out.println(begin + a.toString() + end);
            return;
        } else {
            System.out.println(word);
            return;
        }
    }
}
```

//22.1.18

## Kattis 

### **Problem ID:** qaly

**题目内容**： 几行数字，每行第一个是质量系数，第二个是时间长度，最后需要输出一个总共的zhiliang

**分析**：每行的系数乘上时间长度加起来就是最后的结果记得保留三位小数

**代码**：

```python
num = int(input())
res = 0
for i in range(num):
    lst = list(map(float, input().strip().split()))
    res += lst[0]*lst[1]
print(res)
```



### **Problem ID:** electricaloutlets

**题目内容**：一排插座，互相插最后能有多少个电器可以同时使用

**分析**：不难分析每个插座必须要一个小孔，所以看一共有多少个小孔然后减去需要对于插座的孔就是最后剩下来可以用电器的孔

**代码**：

```python
num = int(input())
for i in range(num):
    lst = list(map(int, input().strip().split()))
    strips = lst[0]
    total = 0
    for i in range(1, strips+1):
        total += lst[i]
    total -= (strips - 1)
    print(total)
```



### **Problem ID:** fiftyshades

**题目内容**：看字符串里面有没有pink或者rose

**分析**：使用find方法不难找到，注意大小写，为了避免这个问题，可以开始把镀金来的words都进行lower（）操作

**代码**：

```python
nums = int(input())
res = 0
for i in range(nums):
    letters = input().lower()
    if "pink" in letters or "rose" in letters:
        res += 1
if res == 0:
    print("I must watch Star Wars with my daughter")
else:
    print(res)
```



### **Problem ID:** islands3

**题目内容**：L陆地C云W水，读进来一堆字母，看最后至少有多少块陆地

**分析**：典型dfs，其实拿dp也可以做，但是作者目前还没写dp的方法后续可能会在补题的时候update

**代码**：

```python
def isWithinBounds(map, x, y):
    return 0 <= x and x < width and 0 <= y and y < height

def get(map, x, y):
    if isWithinBounds(map, x, y):
        return map[y][x]
    else:
        return None

def set(map, x, y, value):
    if isWithinBounds(map, x, y):
        map[y][x] = value

def normalizeLand(map, x, y, newFieldValue):
    field = get(map, x, y)
    if field != "C" and field != "L":
        return

    set(map, x, y, newFieldValue)
    normalizeLand(map, x-1, y, newFieldValue)
    normalizeLand(map, x+1, y, newFieldValue)
    normalizeLand(map, x, y-1, newFieldValue)
    normalizeLand(map, x, y+1, newFieldValue)

def normalize(map):
    islandNumber = 0
    for y in range(height):
        for x in range(width):
            field = get(map, x, y)
            if field == "L":
                islandNumber += 1
                normalizeLand(map, x, y, islandNumber)

    print(islandNumber)


mapSize = input().split()
height = int(mapSize[0])
width = int(mapSize[1])

map = []
for _ in range(height):
    row = list(input())
    map.append(row)

normalize(map)
```



### **Problem ID:** musicalnotation

**题目内容**：读一行string，里面全是各种调调比如CDE，后面可能跟着一整数代表有没有连续，比如C2就是C连续弹两次，每个音符之后都有一个单位的停顿

**分析**：题目本身不难，通过for循环先找到后面带数字的那些特别注意一下如果带数字就连续n次，不带就正常写一次

**代码**：

```python
nums = int(input())
notes = list(input().strip().split())
total = 0
for note in notes:
    if len(note) == 1:
        total += 2
    else:
        total += (int(note[1])+1)
total -= 1

dic = {}
dic["G"] = [" " for _ in range(total)]
dic["F"] = ["-" for _ in range(total)]
dic["E"] = [" " for _ in range(total)]
dic["D"] = ["-" for _ in range(total)]
dic["C"] = [" " for _ in range(total)]
dic["B"] = ["-" for _ in range(total)]
dic["A"] = [" " for _ in range(total)]
dic["g"] = ["-" for _ in range(total)]
dic["f"] = [" " for _ in range(total)]
dic["e"] = ["-" for _ in range(total)]
dic["d"] = [" " for _ in range(total)]
dic["c"] = [" " for _ in range(total)]
dic["b"] = [" " for _ in range(total)]
dic["a"] = ["-" for _ in range(total)]

tmp = 0
for note in notes:
    if len(note) == 1:
        dic[note][tmp] = "*"
        tmp += 2
    else:
        letter = note[0]
        t = int(note[1])
        for i in range(t):
            dic[letter][tmp+i] = "*"
        tmp += (1+t)
for i in ["G", "F", "E", "D", "C", "B", "A", "g", "f", "e", "d", "c", "b", "a"]:
    res = ""
    res += f"{i}: "
    for j in dic[i]:
        res += j
    print(res)
```



##  Leetcode

### 2133

**题目内容**：对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。

给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。

**分析**：无脑写helper检查行检查列

**代码**：

```python
class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        def isValid(lst):
            n = len(lst)
            for i in range(1, n+1):
                if i not in lst:
                    return False
            return True
        n = len(matrix)
        for i in range(n):
            row = matrix[i]
            if not isValid(row):
                return False
        for i in range(n):
            column = []
            for j in range(n):
                column.append(matrix[j][i])
            if not isValid(column):
                return False

        return True
```



### 2134

**题目内容**：交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。

环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。

给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。

**分析**：定长滑窗问题，注意是环形数组，作者开始打算二倍nums做，但是不幸RE， 所以之后选择维护数组。要计算交换的次数其实就是统计这个区间里面0的数量

**代码**：

```python
class Solution:
    def minSwaps(self, nums: List[int]) -> int:
        n = len(nums)
        cnt = sum(nums)
        if cnt == 0:
            return 0
        
        cur = 0
        for i in range(cnt):
            cur += (1 - nums[i])
        
        ans = cur
        for i in range(1, n):
            if nums[i - 1] == 0:
                cur -= 1
            if nums[(i + cnt - 1) % n] == 0:
                cur += 1
            ans = min(ans, cur)
        return ans
```



### 2138

题目内容：分割字符串s，每一段都要有k个字母，如果最后缺少字母我们用fill来去补

分析：典型字符串分割问题，开始看能否正好分割，不能的话直接补成可以正好分割的样子再去分割

代码：

```python
class Solution:
    def divideString(self, s: str, k: int, fill: str) -> List[str]:
        n = len(s)
        res = []
        if n % k != 0:
            require = k * (n//k) + k - n
            for _ in range(require):
                s += fill
        for i in range(len(s)//k):
            ans = s[i*k:(i+1)*k]
            res.append(ans)
        return res
```



### 2139

题目内容：整数游戏，从i开始到target，我们可以递增（+1）或者加倍（*2， 我们这里规定最后maxDouble次加倍，最后返回出最少行动次数

分析：不难分析如果这个target是偶数的时候我们最优解是加倍，如果没有加倍我们才会选择递增，而当target是单数的时候我们没办法加倍只能递增。

代码：

```python
class Solution:
    def minMoves(self, target: int, maxDoubles: int) -> int:
        total = 0
        while maxDoubles > 0 and target != 1:
            if target % 2 != 0:
                target -= 1
                total += 1
            else:
                target /= 2
                maxDoubles -= 1
                total += 1
        total += (target - 1)
        return int(total)
```



### 2140

题目内容：二维数组q， 每个的第0位表示回答这道题获得的文书，第1位表示回答这道题之后需要跳过的题数， 返回着敞开中你能获得的最高分数

分析：有一题目很明显是要你的极值，而且有两个状态，第一个题目数第二个跳过还是解决，我们使用动态规划，建立一维数组dp，第i个代表第i个问题能获得的最高的分数， 由于这道题属于跳过与否所以反向dp从最后一位往前规划，代码如下

代码：

```python
class Solution:
    def mostPoints(self, questions: List[List[int]]) -> int:
        
        n = len(questions)
        dp = [0] * n
        for i in range(n-1, -1, -1):
            end = i + questions[i][1] + 1
            dp[i] = questions[i][0]
            if end < n:
                dp[i] = questions[i][0] + dp[end]
            if i < n-1:
                dp[i] = max(dp[i], dp[i+1])
        return dp[0]
```



### 2141

题目内容：你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。

一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。

注意，你不能给电池充电。

请你返回你可以让 n 台电脑同时运行的 最长 分钟数。

分析：典型二分法做，因为每个电池能供电的时间是本身电量和你要求供电时间的最小值，之后看能不能供到你想要的那个时间，如果不能就缩小，能的话就变大

代码：

```python
class Solution:
    def maxRunTime(self, n: int, batteries: List[int]) -> int:
        left, right, ans = 0, sum(batteries) // n, 0
        while left <= right:
            mid = (left + right) // 2
            total = 0
            for cap in batteries:
                total += min(cap, mid)
            if total >= n * mid:
                ans = mid
                left = mid + 1
            else:
                right = mid -1
        return ans
```

