# 刷题记录

### 声明：

该刷题记录仅供参考以及学习方法，请勿直接ctrl cv到自己的作业上面去，作者概不负责。。。。。。。。。

##  Codeforce

### 4A

#### Watermelon

题目内容： 把一个整数分成两个相同的正整数，并使这两个正整数都是二的倍数

分析： 既然分成两个正整数且都是二的倍数那么这个一定是 $num = 2(a+b)$       $(a, b > 0) $

代码：

C++

```c++
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int a;
    cin >> a;
    if (a == 2) {
        cout << "NO" << endl;
        return;
    }
    if (a % 2 == 0) {
        cout << "YES" << endl;
        return;
    } else {
        cout << "NO" << endl;
        return;
    }
}

int main() {
    solve();
}
```



Python3

```python
n = int(input())
def solve(n):
    if n == 2:
        print("NO")
        return
    if n % 2 == 0:
        print("YES")
        return
    print("NO")

solve(n)
```



Java

```java
import java.util.*;


class A_Watermelon{
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        solve(n);

    }

    static void solve(int n) {
        if (n == 2) {
            System.out.println("NO");
            return;
        }
        if (n % 2 == 0) {
            System.out.println("YES");
            return;
        } else {
            System.out.println("NO");
            return;
        }

    }
}
```

// 22.1.18

### 71A

#### Way too long words

题目内容：缩略单词，长度大于10就保留开头结尾中间数字是没写的单词的个数

分析：if判断长度，print出来

代码：

Python

```python
t = int(input())

def solve(word):
    n = len(word)
    if n > 10:
        begin = word[0]
        end = word[-1]
        res = begin + str(n-2) + end
        print(res)
        return
    else:
        print(word)
        return

for i in range(t):
    word = input()
    solve(word)
```



C++

```C++
#include<bits/stdc++.h>
using namespace std;

void solve(string word) {
    int n = word.length();
    if (n > 10) {
        char begin = word.at(0);
        char end = word.at(n-1);
        cout << begin << n-2 << end << endl;
    } else {
        cout << word << endl;
    }

}
int main() {
    int t;
    cin >> t;
    for (int i = 0; i < t; i++) {
        string word;
        cin >> word;
        solve(word);
    }

    return 0;
}
```



Java 

```java
import java.util.* ;


class A_Way_Too_Long_Words{
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for (int i = 0; i <= t; i++){
            String word1 = s.nextLine();
            solve(word1);
        }
        s.close();
    }

    static void solve(String word) {
        int n = word.length();
        if (n > 10) {
            char begin = word.charAt(0);
            char end = word.charAt(n-1);
            Integer a = n-2;
            System.out.println(begin + a.toString() + end);
            return;
        } else {
            System.out.println(word);
            return;
        }
    }
}
```

//22.1.18

## Kattis 

### **Problem ID:** qaly

题目内容： 几行数字，每行第一个是质量系数，第二个是时间长度，最后需要输出一个总共的zhiliang

分析：每行的系数乘上时间长度加起来就是最后的结果记得保留三位小数

代码：

```python
num = int(input())
res = 0
for i in range(num):
    lst = list(map(float, input().strip().split()))
    res += lst[0]*lst[1]
print(res)
```



### **Problem ID:** electricaloutlets

题目内容：一排插座，互相插最后能有多少个电器可以同时使用

分析：不难分析每个插座必须要一个小孔，所以看一共有多少个小孔然后减去需要对于插座的孔就是最后剩下来可以用电器的孔

代码：

```python
num = int(input())
for i in range(num):
    lst = list(map(int, input().strip().split()))
    strips = lst[0]
    total = 0
    for i in range(1, strips+1):
        total += lst[i]
    total -= (strips - 1)
    print(total)
```



### **Problem ID:** fiftyshades

题目内容：看字符串里面有没有pink或者rose

分析：使用find方法不难找到，注意大小写，为了避免这个问题，可以开始把镀金来的words都进行lower（）操作

代码：

```python
nums = int(input())
res = 0
for i in range(nums):
    letters = input().lower()
    if "pink" in letters or "rose" in letters:
        res += 1
if res == 0:
    print("I must watch Star Wars with my daughter")
else:
    print(res)
```



### **Problem ID:** islands3

题目内容：L陆地C云W水，读进来一堆字母，看最后至少有多少块陆地

分析：典型dfs，其实拿dp也可以做，但是作者目前还没写dp的方法后续可能会在补题的时候update

代码：

```python
def isWithinBounds(map, x, y):
    return 0 <= x and x < width and 0 <= y and y < height

def get(map, x, y):
    if isWithinBounds(map, x, y):
        return map[y][x]
    else:
        return None

def set(map, x, y, value):
    if isWithinBounds(map, x, y):
        map[y][x] = value

def normalizeLand(map, x, y, newFieldValue):
    field = get(map, x, y)
    if field != "C" and field != "L":
        return

    set(map, x, y, newFieldValue)
    normalizeLand(map, x-1, y, newFieldValue)
    normalizeLand(map, x+1, y, newFieldValue)
    normalizeLand(map, x, y-1, newFieldValue)
    normalizeLand(map, x, y+1, newFieldValue)

def normalize(map):
    islandNumber = 0
    for y in range(height):
        for x in range(width):
            field = get(map, x, y)
            if field == "L":
                islandNumber += 1
                normalizeLand(map, x, y, islandNumber)

    print(islandNumber)


mapSize = input().split()
height = int(mapSize[0])
width = int(mapSize[1])

map = []
for _ in range(height):
    row = list(input())
    map.append(row)

normalize(map)
```



### **Problem ID:** musicalnotation

题目内容：读一行string，里面全是各种调调比如CDE，后面可能跟着一整数代表有没有连续，比如C2就是C连续弹两次，每个音符之后都有一个单位的停顿

分析：题目本身不难，通过for循环先找到后面带数字的那些特别注意一下如果带数字就连续n次，不带就正常写一次

代码：

```python
nums = int(input())
notes = list(input().strip().split())
total = 0
for note in notes:
    if len(note) == 1:
        total += 2
    else:
        total += (int(note[1])+1)
total -= 1

dic = {}
dic["G"] = [" " for _ in range(total)]
dic["F"] = ["-" for _ in range(total)]
dic["E"] = [" " for _ in range(total)]
dic["D"] = ["-" for _ in range(total)]
dic["C"] = [" " for _ in range(total)]
dic["B"] = ["-" for _ in range(total)]
dic["A"] = [" " for _ in range(total)]
dic["g"] = ["-" for _ in range(total)]
dic["f"] = [" " for _ in range(total)]
dic["e"] = ["-" for _ in range(total)]
dic["d"] = [" " for _ in range(total)]
dic["c"] = [" " for _ in range(total)]
dic["b"] = [" " for _ in range(total)]
dic["a"] = ["-" for _ in range(total)]

tmp = 0
for note in notes:
    if len(note) == 1:
        dic[note][tmp] = "*"
        tmp += 2
    else:
        letter = note[0]
        t = int(note[1])
        for i in range(t):
            dic[letter][tmp+i] = "*"
        tmp += (1+t)
for i in ["G", "F", "E", "D", "C", "B", "A", "g", "f", "e", "d", "c", "b", "a"]:
    res = ""
    res += f"{i}: "
    for j in dic[i]:
        res += j
    print(res)
```



##  Leetcode

